{
  "name": "wave-effect-card",
  "type": "registry:ui",
  "title": "Wave Effect Card",
  "description": "An animated card grid component featuring a ripple wave effect that emanates from the center, creating a dynamic opacity reveal animation across button-style cards with a centered privacy-themed overlay.",
  "dependencies": ["framer-motion", "react-icons"],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/ui/wave-effect-card.tsx",
      "content": "\"use client\";\n\nimport React, {\n  memo,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useMemo,\n} from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { cn } from \"@/lib/utils\";\nimport { HiMiniLockClosed } from \"react-icons/hi2\";\n\ninterface CardItem {\n  id: number;\n  label: string;\n  width: \"sm\" | \"md\" | \"lg\" | \"xl\";\n}\n\ninterface CardPosition {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\ninterface WaveEffectCardProps {\n  items?: string[];\n  waveSpeed?: number;\n  waveThickness?: number;\n  fadeWidth?: number;\n  baseOpacity?: number;\n  activeOpacity?: number;\n  className?: string;\n  title?: string;\n  subtitle?: string;\n  description?: string;\n  icon?: React.ReactNode;\n  glowDuration?: number;\n}\n\nconst SECURITY_WORDS = [\n  \"Encrypt\", \"Shield\", \"Guard\", \"Secure\", \"Protect\",\n  \"Private\", \"Safety\", \"Locked\", \"Cipher\", \"Verify\",\n  \"Trust\", \"Defense\", \"Firewall\", \"Auth\", \"Token\",\n  \"Hash\", \"SSL\", \"VPN\", \"2FA\", \"Biometric\",\n  \"Access\", \"Vault\", \"Key\", \"Secret\", \"Stealth\",\n  \"Armor\", \"Sentinel\", \"Fortress\", \"Barrier\", \"Filter\",\n  \"Sandbox\", \"Proxy\", \"Audit\", \"Comply\", \"GDPR\",\n  \"Zero-Trust\", \"E2E\", \"AES\", \"RSA\", \"HTTPS\",\n];\n\nconst DEFAULT_ITEMS = Array(80)\n  .fill(null)\n  .map((_, i) => SECURITY_WORDS[i % SECURITY_WORDS.length]);\n\nconst WIDTH_CLASSES: Record<CardItem[\"width\"], string> = {\n  sm: \"w-14 sm:w-16\",\n  md: \"w-18 sm:w-20\",\n  lg: \"w-22 sm:w-24\",\n  xl: \"w-26 sm:w-28\",\n};\n\nconst WIDTH_PATTERN: CardItem[\"width\"][] = [\n  \"md\", \"lg\", \"sm\", \"xl\", \"md\", \"sm\", \"lg\", \"md\", \"xl\", \"sm\",\n  \"lg\", \"md\", \"sm\", \"xl\", \"lg\", \"md\", \"sm\", \"lg\", \"lg\", \"md\",\n  \"sm\", \"xl\", \"lg\", \"md\", \"sm\", \"lg\", \"md\", \"md\", \"xl\", \"sm\",\n  \"lg\", \"md\", \"sm\", \"xl\", \"lg\", \"md\", \"sm\", \"lg\", \"xl\", \"md\",\n  \"sm\", \"lg\", \"md\", \"xl\", \"sm\", \"md\", \"lg\", \"sm\", \"xl\", \"md\",\n];\n\nconst easeInOutSine = (t: number): number => {\n  return -(Math.cos(Math.PI * t) - 1) / 2;\n};\n\nconst calculateOpacity = (\n  distance: number,\n  innerRadius: number,\n  outerRadius: number,\n  fadeWidth: number,\n  baseOpacity: number,\n  activeOpacity: number\n): number => {\n  const innerFadeStart = innerRadius - fadeWidth;\n  const outerFadeEnd = outerRadius + fadeWidth;\n\n  if (distance < innerFadeStart || distance > outerFadeEnd) {\n    return baseOpacity;\n  }\n\n  if (distance >= innerRadius && distance <= outerRadius) {\n    return activeOpacity;\n  }\n\n  if (distance >= innerFadeStart && distance < innerRadius) {\n    const t = (distance - innerFadeStart) / fadeWidth;\n    const easedT = easeInOutSine(t);\n    return baseOpacity + (activeOpacity - baseOpacity) * easedT;\n  }\n\n  if (distance > outerRadius && distance <= outerFadeEnd) {\n    const t = (distance - outerRadius) / fadeWidth;\n    const easedT = easeInOutSine(t);\n    return activeOpacity - (activeOpacity - baseOpacity) * easedT;\n  }\n\n  return baseOpacity;\n};\n\nconst Card = memo(\n  ({\n    item,\n    opacity,\n    cardRef,\n  }: {\n    item: CardItem;\n    opacity: number;\n    cardRef: (el: HTMLDivElement | null) => void;\n  }) => (\n    <div\n      ref={cardRef}\n      className={cn(\n        \"h-7 sm:h-8 rounded-md border border-neutral-200/80 dark:border-neutral-700/80\",\n        \"bg-neutral-200/50 dark:bg-neutral-900/80 flex items-center justify-center\",\n        \"text-xs font-mono font-medium text-neutral-500 dark:text-neutral-400\",\n        \"transition-opacity duration-100\",\n        WIDTH_CLASSES[item.width]\n      )}\n      style={{ opacity }}\n    >\n      <span className=\"truncate px-1.5\">{item.label}</span>\n    </div>\n  )\n);\n\nCard.displayName = \"Card\";\n\ntype AnimationPhase = \"charging\" | \"pulse\" | \"wave\" | \"idle\";\n\nexport const WaveEffectCard = memo(\n  ({\n    items = DEFAULT_ITEMS,\n    waveSpeed = 100,\n    waveThickness = 80,\n    fadeWidth = 50,\n    baseOpacity = 0.2,\n    activeOpacity = 0.75,\n    className,\n    title = \"We're serious about privacy.\",\n    subtitle = \"Your data is built with privacy at its core.\",\n    description = \"We never train on your data.\",\n    icon,\n    glowDuration = 0.6,\n  }: WaveEffectCardProps) => {\n    const containerRef = useRef<HTMLDivElement>(null);\n    const cardRefsMap = useRef<Map<number, HTMLDivElement>>(new Map());\n    const animationFrameRef = useRef<number | null>(null);\n    const startTimeRef = useRef<number | null>(null);\n\n    const [cardOpacities, setCardOpacities] = useState<Map<number, number>>(new Map());\n    const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n    const [animationPhase, setAnimationPhase] = useState<AnimationPhase>(\"charging\");\n    const [rippleKey, setRippleKey] = useState(0);\n\n    const cardItems = useMemo<CardItem[]>(\n      () =>\n        items.map((label, index) => ({\n          id: index,\n          label,\n          width: WIDTH_PATTERN[index % WIDTH_PATTERN.length],\n        })),\n      [items]\n    );\n\n    const maxRadius = useMemo(() => {\n      return Math.sqrt(\n        Math.pow(containerSize.width / 2, 2) +\n        Math.pow(containerSize.height / 2, 2)\n      );\n    }, [containerSize]);\n\n    const getCardPosition = useCallback((id: number): CardPosition | null => {\n      const card = cardRefsMap.current.get(id);\n      const container = containerRef.current;\n      if (!card || !container) return null;\n\n      const cardRect = card.getBoundingClientRect();\n      const containerRect = container.getBoundingClientRect();\n\n      return {\n        x: cardRect.left - containerRect.left + cardRect.width / 2,\n        y: cardRect.top - containerRect.top + cardRect.height / 2,\n        width: cardRect.width,\n        height: cardRect.height,\n      };\n    }, []);\n\n    const animate = useCallback(\n      (timestamp: number) => {\n        if (startTimeRef.current === null) {\n          startTimeRef.current = timestamp;\n        }\n\n        const elapsed = timestamp - startTimeRef.current;\n        const currentRadius = (elapsed * waveSpeed) / 1000;\n        const totalCycleDistance = maxRadius + waveThickness + fadeWidth * 2;\n\n        if (currentRadius >= totalCycleDistance) {\n          const resetOpacities = new Map<number, number>();\n          cardItems.forEach((item) => {\n            resetOpacities.set(item.id, baseOpacity);\n          });\n          setCardOpacities(resetOpacities);\n\n          if (animationFrameRef.current !== null) {\n            cancelAnimationFrame(animationFrameRef.current);\n            animationFrameRef.current = null;\n          }\n          startTimeRef.current = null;\n          setAnimationPhase(\"charging\");\n          return;\n        }\n\n        const innerRadius = Math.max(0, currentRadius - waveThickness);\n        const outerRadius = currentRadius;\n\n        const centerX = containerSize.width / 2;\n        const centerY = containerSize.height / 2;\n\n        const newOpacities = new Map<number, number>();\n\n        cardItems.forEach((item) => {\n          const position = getCardPosition(item.id);\n          if (position) {\n            const distance = Math.sqrt(\n              Math.pow(position.x - centerX, 2) +\n              Math.pow(position.y - centerY, 2)\n            );\n\n            const opacity = calculateOpacity(\n              distance,\n              innerRadius,\n              outerRadius,\n              fadeWidth,\n              baseOpacity,\n              activeOpacity\n            );\n\n            newOpacities.set(item.id, opacity);\n          } else {\n            newOpacities.set(item.id, baseOpacity);\n          }\n        });\n\n        setCardOpacities(newOpacities);\n        animationFrameRef.current = requestAnimationFrame(animate);\n      },\n      [\n        cardItems,\n        containerSize,\n        maxRadius,\n        waveSpeed,\n        waveThickness,\n        fadeWidth,\n        baseOpacity,\n        activeOpacity,\n        getCardPosition,\n      ]\n    );\n\n    const handleChargingComplete = useCallback(() => {\n      if (animationPhase === \"charging\") {\n        setAnimationPhase(\"pulse\");\n        setRippleKey((prev) => prev + 1);\n      }\n    }, [animationPhase]);\n\n    const handlePulseComplete = useCallback(() => {\n      if (animationPhase === \"pulse\") {\n        setAnimationPhase(\"wave\");\n      }\n    }, [animationPhase]);\n\n    useEffect(() => {\n      if (animationPhase === \"wave\" && containerSize.width > 0 && containerSize.height > 0) {\n        startTimeRef.current = null;\n        animationFrameRef.current = requestAnimationFrame(animate);\n      }\n\n      return () => {\n        if (animationFrameRef.current !== null) {\n          cancelAnimationFrame(animationFrameRef.current);\n          animationFrameRef.current = null;\n        }\n      };\n    }, [animationPhase, animate, containerSize]);\n\n    useEffect(() => {\n      const container = containerRef.current;\n      if (!container) return;\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        const entry = entries[0];\n        if (entry) {\n          setContainerSize({\n            width: entry.contentRect.width,\n            height: entry.contentRect.height,\n          });\n        }\n      });\n\n      resizeObserver.observe(container);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }, []);\n\n    const setCardRef = useCallback(\n      (id: number) => (el: HTMLDivElement | null) => {\n        if (el) {\n          cardRefsMap.current.set(id, el);\n        } else {\n          cardRefsMap.current.delete(id);\n        }\n      },\n      []\n    );\n\n    const iconButtonVariants = {\n      idle: {\n        scale: 1,\n        boxShadow: \"0 0 0px rgba(59, 130, 246, 0)\",\n      },\n      charging: {\n        scale: [1, 1.1, 1.08],\n        boxShadow: [\n          \"0 0 0px rgba(59, 130, 246, 0)\",\n          \"0 0 35px rgba(59, 130, 246, 0.4), 0 0 70px rgba(59, 130, 246, 0.2)\",\n          \"0 0 45px rgba(59, 130, 246, 0.5), 0 0 90px rgba(59, 130, 246, 0.25)\",\n        ],\n      },\n      pulse: {\n        scale: [1.08, 0.92, 1],\n        boxShadow: [\n          \"0 0 45px rgba(59, 130, 246, 0.5), 0 0 90px rgba(59, 130, 246, 0.25)\",\n          \"0 0 15px rgba(59, 130, 246, 0.2)\",\n          \"0 0 0px rgba(59, 130, 246, 0)\",\n        ],\n      },\n    };\n\n    const getIconAnimationState = () => {\n      if (animationPhase === \"charging\") return \"charging\";\n      if (animationPhase === \"pulse\") return \"pulse\";\n      return \"idle\";\n    };\n\n    return (\n      <div className=\"max-w-xl relative mx-auto h-96 overflow-hidden rounded-2xl border border-neutral-200 dark:border-neutral-900 bg-white dark:bg-neutral-950 shadow-sm\">\n        <div\n          ref={containerRef}\n          className={cn(\n            \"flex absolute -top-8 -left-8 w-[calc(100%+4rem)] flex-wrap gap-2 justify-center items-center p-4 select-none pointer-events-none\",\n            \"opacity-50 [mask-image:radial-gradient(ellipse_at_center,black_30%,transparent_70%)]\",\n            className\n          )}\n        >\n          {cardItems.map((item) => (\n            <Card\n              key={item.id}\n              item={item}\n              opacity={cardOpacities.get(item.id) ?? baseOpacity}\n              cardRef={setCardRef(item.id)}\n            />\n          ))}\n        </div>\n\n        <div className=\"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col space-y-4 items-center justify-center pointer-events-none z-10\">\n          <div className=\"relative\">\n            <AnimatePresence>\n              {(animationPhase === \"pulse\" || animationPhase === \"wave\") && (\n                <motion.div\n                  key={rippleKey}\n                  className=\"absolute inset-0 rounded-full\"\n                  initial={{ scale: 1, opacity: 0.5 }}\n                  animate={{\n                    scale: 8,\n                    opacity: 0,\n                  }}\n                  transition={{\n                    duration: 1.2,\n                    ease: \"easeOut\",\n                  }}\n                  style={{\n                    transformOrigin: \"center\",\n                    background: \"radial-gradient(circle, rgba(59, 130, 246, 0.4) 0%, rgba(59, 130, 246, 0) 70%)\",\n                  }}\n                />\n              )}\n            </AnimatePresence>\n\n            <motion.div\n              className={cn(\n                \"relative rounded-2xl p-4\",\n                \"bg-gradient-to-br from-white to-neutral-200 dark:from-neutral-800 dark:to-neutral-900\",\n                \"border-t border-l border-white outline-2 outline-neutral-200/50 dark:outline-neutral-800 dark:border-neutral-600/80\",\n                \"shadow-xl shadow-blue-500/10\"\n              )}\n              variants={iconButtonVariants}\n              initial=\"idle\"\n              animate={getIconAnimationState()}\n              transition={{\n                duration: animationPhase === \"charging\" ? glowDuration : 0.35,\n                ease: animationPhase === \"charging\" ? [0.4, 0, 0.2, 1] : [0.25, 0.1, 0.25, 1],\n                times: animationPhase === \"charging\" ? [0, 0.5, 1] : [0, 0.3, 1],\n              }}\n              onAnimationComplete={\n                animationPhase === \"charging\"\n                  ? handleChargingComplete\n                  : animationPhase === \"pulse\"\n                    ? handlePulseComplete\n                    : undefined\n              }\n            >\n              {icon || <HiMiniLockClosed className=\"w-8 h-8 text-blue-500 dark:text-blue-500\" />}\n            </motion.div>\n          </div>\n          <div className=\"flex flex-col items-center space-y-2\">\n            <span className=\"text-2xl sm:text-2xl font-bold tracking-tight text-neutral-900 dark:text-white text-center\">\n              {title}\n            </span>\n            <span className=\"text-sm sm:text-sm text-neutral-600 dark:text-neutral-400 text-center max-w-sm leading-relaxed\">\n              {subtitle} {description}\n            </span>\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\n\nWaveEffectCard.displayName = \"WaveEffectCard\";\n\nexport default WaveEffectCard;",
      "type": "registry:ui",
      "target": "components/ui/wave-effect-card.tsx"
    }
  ]
}
